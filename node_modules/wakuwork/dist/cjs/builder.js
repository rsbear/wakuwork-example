"use strict";Object.defineProperty(exports,"__esModule",{value:true});Object.defineProperty(exports,"runBuild",{enumerable:true,get:()=>runBuild});const _nodePath=_interopRequireDefault(require("node:path"));const _nodeFs=_interopRequireDefault(require("node:fs"));const _nodeModule=require("node:module");const _vite=require("vite");const _pluginReact=_interopRequireDefault(require("@vitejs/plugin-react"));const _core=_interopRequireWildcard(require("@swc/core"));const _react=require("react");const _server=_interopRequireDefault(require("react-server-dom-webpack/server"));const _rewriteRscJs=require("./middleware/rewriteRsc.js");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!=="function")return null;var cacheBabelInterop=new WeakMap;var cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj}if(obj===null||typeof obj!=="object"&&typeof obj!=="function"){return{default:obj}}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj)}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!=="default"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc)}else{newObj[key]=obj[key]}}}newObj.default=obj;if(cache){cache.set(obj,newObj)}return newObj}const{renderToPipeableStream}=_server.default;const CLIENT_REFERENCE=Symbol.for("react.client.reference");const rscPlugin=()=>{const code=`
globalThis.__webpack_require__ = (id) => {
  const cache = globalThis.__webpack_require__wakuwork_cache;
  if (cache && cache.has(id)) return cache.get(id);
  return import(id);
};`;return{name:"rscPlugin",async transformIndexHtml(){return[{tag:"script",children:code,injectTo:"body"}]}}};const walkDirSync=(dir,callback)=>{_nodeFs.default.readdirSync(dir,{withFileTypes:true}).forEach(dirent=>{const filePath=_nodePath.default.join(dir,dirent.name);if(dirent.isDirectory()){if(dirent.name!=="node_modules"){walkDirSync(filePath,callback)}}else{callback(filePath)}})};const getClientEntryFiles=dir=>{const files=[];walkDirSync(dir,fname=>{if(fname.endsWith(".ts")||fname.endsWith(".tsx")){const mod=_core.parseFileSync(fname,{syntax:"typescript",tsx:fname.endsWith(".tsx")});for(const item of mod.body){if(item.type==="ExpressionStatement"&&item.expression.type==="StringLiteral"&&item.expression.value==="use client"){files.push(fname)}}}});return files};const compileFiles=(dir,distPath)=>{walkDirSync(dir,fname=>{const relativePath=_nodePath.default.relative(dir,fname);if(relativePath.startsWith(distPath)){return}if(fname.endsWith(".ts")||fname.endsWith(".tsx")){const{code}=_core.transformFileSync(fname,{jsc:{parser:{syntax:"typescript",tsx:fname.endsWith(".tsx")},transform:{react:{runtime:"automatic"}}}});const destFile=_nodePath.default.join(dir,distPath,relativePath.replace(/\.tsx?$/,".js"));_nodeFs.default.mkdirSync(_nodePath.default.dirname(destFile),{recursive:true});_nodeFs.default.writeFileSync(destFile,code)}})};const prerender=async(dir,distPath,publicPath,entriesFile,basePath,indexHtmlFile)=>{const serverEntries={};const registerServerEntry=fileId=>{for(const entry of Object.entries(serverEntries)){if(entry[1]===fileId){return entry[0]}}const id=`rsf${Object.keys(serverEntries).length}`;serverEntries[id]=fileId;return id};const{getEntry,prefetcher,prerenderer,clientEntries}=await Promise.resolve(entriesFile).then(p=>_interopRequireWildcard(require(p)));const getFunctionComponent=async rscId=>{const mod=await getEntry(rscId);if(typeof mod==="function"){return mod}return mod.default};const getClientEntry=id=>{if(!clientEntries){throw new Error("Missing client entries")}const clientEntry=clientEntries[id]||clientEntries[id.replace(/\.js$/,".ts")]||clientEntries[id.replace(/\.js$/,".tsx")];if(!clientEntry){throw new Error("No client entry found")}return clientEntry};const decodeId=encodedId=>{let[id,name]=encodedId.split("#");if(!id.startsWith("wakuwork/")){id=_nodePath.default.relative("file://"+encodeURI(_nodePath.default.join(dir,distPath)),id);id=basePath+getClientEntry(decodeURI(id))}return[id,name]};const bundlerConfig=new Proxy({},{get(_target,encodedId){const[id,name]=decodeId(encodedId);return{id,chunks:[],name,async:true}}});if(prerenderer){const{entryItems=[],paths=[]}=await prerenderer();await Promise.all(Array.from(entryItems).map(async([rscId,props])=>{const serializedProps=JSON.stringify(props);const searchParams=new URLSearchParams;searchParams.set("props",serializedProps);const destFile=_nodePath.default.join(dir,publicPath,"RSC",decodeURIComponent(rscId),decodeURIComponent(`${searchParams}`));_nodeFs.default.mkdirSync(_nodePath.default.dirname(destFile),{recursive:true});const component=await getFunctionComponent(rscId);if(component){await new Promise((resolve,reject)=>{const stream=_nodeFs.default.createWriteStream(destFile);stream.on("finish",resolve);stream.on("error",reject);renderToPipeableStream((0,_react.createElement)(component,props),bundlerConfig).pipe((0,_rewriteRscJs.transformRsfId)("file://"+encodeURI(_nodePath.default.join(dir,distPath)),registerServerEntry)).pipe(stream)})}}));for(const pathItem of paths){let code="";if(prefetcher){const{entryItems=[],clientModules=[]}=await prefetcher(pathItem);const moduleIds=[];for(const m of clientModules){if(m["$$typeof"]!==CLIENT_REFERENCE){throw new Error("clientModules must be client references")}const[id]=decodeId(m["$$id"]);moduleIds.push(id)}code+=_rewriteRscJs.generatePrefetchCode?.(entryItems,moduleIds)||""}if(code){const destFile=_nodePath.default.join(dir,publicPath,pathItem,pathItem.endsWith("/")?"index.html":"");let content="";if(_nodeFs.default.existsSync(destFile)){content=_nodeFs.default.readFileSync(destFile,{encoding:"utf8"})}else{_nodeFs.default.mkdirSync(_nodePath.default.dirname(destFile),{recursive:true});content=_nodeFs.default.readFileSync(indexHtmlFile,{encoding:"utf8"})}let index=content.lastIndexOf("</body>");if(index===-1){throw new Error("No </body> found in html")}content=`${content.slice(0,index)}
<script>
${code}
</script>${content.slice(index)}`;_nodeFs.default.writeFileSync(destFile,content,{encoding:"utf8"})}}}return serverEntries};async function runBuild(config={}){const dir=_nodePath.default.resolve(config.build?.dir||".");const basePath=config.build?.basePath||"/";const distPath=config.files?.dist||"dist";const publicPath=_nodePath.default.join(distPath,config.files?.public||"public");const indexHtmlFile=_nodePath.default.join(dir,config.files?.indexHtml||"index.html");const entriesFile=_nodePath.default.join(dir,distPath,config.files?.entriesJs||"entries.js");const require1=(0,_nodeModule.createRequire)(require("url").pathToFileURL(__filename).toString());const clientEntryFiles=Object.fromEntries(getClientEntryFiles(dir).map((fname,i)=>[`rsc${i}`,fname]));const output=await (0,_vite.build)({root:dir,base:basePath,plugins:[(0,_pluginReact.default)(),rscPlugin()],build:{outDir:publicPath,rollupOptions:{input:{main:indexHtmlFile,...clientEntryFiles},preserveEntrySignatures:"exports-only"}}});const clientEntries={};if(!("output"in output)){throw new Error("Unexpected vite build output")}for(const item of output.output){const{name,fileName}=item;const entryFile=name&&clientEntryFiles[name];if(entryFile){clientEntries[_nodePath.default.relative(dir,entryFile)]=fileName}}console.log("clientEntries",clientEntries);compileFiles(dir,distPath);_nodeFs.default.appendFileSync(entriesFile,`export const clientEntries=${JSON.stringify(clientEntries)};`);const serverEntries=await prerender(dir,distPath,publicPath,entriesFile,basePath,indexHtmlFile);console.log("serverEntries",serverEntries);_nodeFs.default.appendFileSync(entriesFile,`export const serverEntries=${JSON.stringify(serverEntries)};`);const origPackageJson=require1(_nodePath.default.join(dir,"package.json"));const packageJson={name:origPackageJson.name,version:origPackageJson.version,private:true,type:"module",scripts:{start:"wakuwork start"},dependencies:origPackageJson.dependencies};_nodeFs.default.writeFileSync(_nodePath.default.join(dir,distPath,"package.json"),JSON.stringify(packageJson,null,2))}